#! /PATH/TO/PYTHON

import numpy
import matplotlib.pyplot as plt
import scipy.signal
from tthelper import add_data
import serial

print('NOTE: (Graph time) = (Samples read)*(Arduino rate)')
max_time = float(raw_input('What should be the max time value during sampling(in milliseconds)?   '))
data_rate = float(raw_input('How many samples would you like to read per time?   '))
loop_rate = float(raw_input('How long does it ideally take to sample this many (in milliseconds)?  '))

(tdata, ampdata0) = (numpy.array([]), numpy.array([]))               # Create empty data arrays
ampdata = (ampdata0, ampdata0)                                       # Holder for amplitude values
line = []                                                            # Holder for line2d attributes
fil_data = ('init', None, None, None)                                # Initialize state variables in tuple
box = scipy.signal.boxcar(50)                                        # Implement extra filter(s)
max_agg = 0                                                          # Keeps track of aggregate max (for scaling)

plt.ion()                                                            # Enable interactive plotting
fig, ax = plt.subplots(2, 1, sharex = True)                          # Initialize subplots
fig2, ax2 = plt.subplots(1, 1, sharex = True)
ax_t = numpy.append(ax,ax2)
for axes in ax_t:
    axes.set_xlim(0.25, max_time/1000+0.25)
    axes.set_ylim(0,0.0003)
    axes.set_ylabel('Average ~(V)')
    axes.set_xlabel('Time(s)')
    line.append(axes.plot(tdata, ampdata0)[0])
ax2.set_ylim(0,1)
ax2.set_ylabel('Normalized Aggregate Response')
ax[0].set_title('Integrated A0 Signal')
ax[1].set_title('Integrated A1 Signal')
ax2.set_title('Aggregate Integrated Voltage')
fig.canvas.draw()
fig2.canvas.draw()

datain = serial.Serial('/dev/ttyACM0', 115200, timeout = 4)
datain.setDTR(False)
datain.setDTR(True)
datcheck = True

while(True):
## WITH HI/LO FILTERING
    (tdata, ampdata, fil_data) = add_data((tdata, ampdata[0], ampdata[1]), data_rate, datain, f_del = fil_data, dchk = datcheck)
## W/O HI/LO FILTERING
#    tdata, ampdata = add_data((tdata, ampdata[0], ampdata[1]), data_rate, datain)

    if datcheck:
        datcheck = False

    toplot = scipy.signal.lfilter(box, 1, numpy.vstack([ampdata, numpy.sum(ampdata, axis=0)]))/50
    if toplot[2].max() > max_agg:
        max_agg = toplot[2].max()
    toplot = numpy.divide(toplot, [[1],[1],[max_agg]])

    if tdata.size > max_time*(data_rate/loop_rate)+50:              # Data Deletion Routine and Axis Adjustment
        where = int(tdata.size - max_time*(data_rate/loop_rate) - 50)
        toplot = [toplot[0][where:], toplot[1][where:], toplot[2][where:]]
        tdata = tdata[where:]
        ampdata = (ampdata[0][where:], ampdata[1][where:])
        for axes in ax_t:
            axes.set_xlim(tdata.min()+0.25, tdata.max())

    for i,lines in enumerate(line):                                 # Plot Updating/Smoothing Routine
        lines.set_ydata(toplot[i])
        lines.set_xdata(tdata)
        ax_t[i].draw_artist(ax_t[i].patch)
        ax_t[i].draw_artist(lines)
    fig.canvas.update()
    fig2.canvas.update()
    fig.canvas.flush_events()
    fig2.canvas.flush_events()
